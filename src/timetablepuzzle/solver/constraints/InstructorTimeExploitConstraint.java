package timetablepuzzle.solver.constraints;

import timetablepuzzle.eclipselink.entities.inputdata.Class;
import timetablepuzzle.eclipselink.entities.inputdata.Solution;

public class InstructorTimeExploitConstraint extends AbstractSoftConstraint{
	private int _maxInstrHoursNoBreak;
	private int _maxInstrHoursPerDay;
	
	/**
	 * Default constructor
	 */
	public InstructorTimeExploitConstraint()
	{
		this.set_maxInstrHoursNoBreak(6);
		this.set_maxInstrHoursPerDay(8);
		this.set_pointsOfPenaltyPerViolation(5);
	}

	/*****************Getters and setters****************/
	public int get_maxInstrHoursNoBreak() {
		return _maxInstrHoursNoBreak;
	}

	public void set_maxInstrHoursNoBreak(int _maxInstrHoursNoBreak) {
		this._maxInstrHoursNoBreak = _maxInstrHoursNoBreak;
	}

	public int get_maxInstrHoursPerDay() {
		return _maxInstrHoursPerDay;
	}

	public void set_maxInstrHoursPerDay(int _maxInstrHoursPerDay) {
		this._maxInstrHoursPerDay = _maxInstrHoursPerDay;
	}
	
	/***********Public methods that define the class behavior**************/
	/**
	 * Returns the total number of penalty point for the solution given 
	 * @param solution
	 * @return
	 */
	public long CalculatePenaltyPoints(Solution solution)
	{
		long totalPPoints = 0;
		for(Class[] instrClasses : solution.get_instructorsTimetable().values())
		{
			totalPPoints += GetPenaltyPointsForInstructor(
					instrClasses, solution.get_nrOfDays(), solution.get_nrOfTimeSlotsPerDay());
		}
		
		return totalPPoints;
	}
	
	/**
	 * Determines the penalty points for a class by subtracting from the pPoints gained
	 *  with the class assigned the pPoints gained with the class unassigned
	 * @param solution
	 * @param selClass
	 * @return
	 */
	public long GetPenaltyPointsForVariable(Solution solution, Class selClass)
	{		
		// TO DO: To check if this does what it is supposed to do
		// Get the classes of the instructor that teaches the selClass
		int dayNTime = solution.get_assignedClasses().get(selClass.getId());
		int instrId = selClass.getAssignedInstructorId();
		Class[] instrClasses = solution.get_instructorsTimetable().get(instrId);
		long pPointsWithClass = GetPenaltyPointsForInstructor(
				 instrClasses, solution.get_nrOfDays(), solution.get_nrOfTimeSlotsPerDay());
		// Unassigns the class temporarily 
		instrClasses[dayNTime] = null;
		Long pPointsWithoutClass = GetPenaltyPointsForInstructor(
				 instrClasses, solution.get_nrOfDays(), solution.get_nrOfTimeSlotsPerDay());
		// Assign the class back in
		instrClasses[dayNTime] = selClass;
		// The penalty points that this class has is calculated as first - the second
		return pPointsWithClass - pPointsWithoutClass;
	}
	
	/**
	 * Returns the penalty points calculated for a given set of classes
	 * @param instrClasses
	 * @param nrOfDays
	 * @param nrOfTimeSlotsPerDay
	 * @return
	 */
	private long GetPenaltyPointsForInstructor(Class[] instrClasses, int nrOfDays, int nrOfTimeSlotsPerDay)
	{
		long pPoints = 0;
		// Helper variables
		int lastOccupiedHour;
		int nrOfConsecutiveHours;
		int hoursOfWorkPerDay;
		// Calculate the number of working hour per day, 
		// and the number of consecutive working hours
		for(int i=0; i<nrOfDays; i++)
		{
			// Reset variables
			lastOccupiedHour = 0;
			nrOfConsecutiveHours = 0;
			hoursOfWorkPerDay = 0;
			// For each time of day
			for(int j=0; j< nrOfTimeSlotsPerDay; j++)
			{
				if(instrClasses[i*nrOfDays + j] != null)
				{
					// The slot is a working hour
					// Count consecutive hours
					if(j == 0)
					{
						nrOfConsecutiveHours++;
					}else{
						 if(lastOccupiedHour == j-1)
						 {
							 nrOfConsecutiveHours++; 
						 }else{
							 nrOfConsecutiveHours = 0;
						 }
					}
					// Check constraint and calculate penalty points
					if(nrOfConsecutiveHours > _maxInstrHoursNoBreak)
					{
						pPoints += get_pointsOfPenaltyPerViolation();
					}
					lastOccupiedHour = j;
					hoursOfWorkPerDay++;
					if(hoursOfWorkPerDay > _maxInstrHoursPerDay)
					{
						pPoints += get_pointsOfPenaltyPerViolation();
					}
				}
			}
		}
		
		return pPoints;
	}
}
