package timetablepuzzle.solver.constraints;

import timetablepuzzle.eclipselink.entities.inputdata.Class;
import timetablepuzzle.eclipselink.entities.inputdata.Solution;

public class InstructorTimeExploitConstraint extends AbstractSoftConstraint{
	public static final int DefaultMaxWorkingHoursWithoutBreak = 6;
	public static final int DefaultMaxWorkingHoursPerDay = 10;
	
	private int maxInstrHoursNoBreak;
	private int maxInstrHoursPerDay;

	public InstructorTimeExploitConstraint(Solution solution)
	{
		super(solution);
		this.setMaxInstrHoursNoBreak(DefaultMaxWorkingHoursWithoutBreak);
		this.setMaxInstrHoursPerDay(DefaultMaxWorkingHoursPerDay);
		this.setNrOfPenaltyPointsPerViolation(DefaultNrOfPenaltyPointsPerViolation);
	}

	/*****************Getters and setters****************/
	public int getMaxInstrHoursNoBreak() {
		return maxInstrHoursNoBreak;
	}

	public void setMaxInstrHoursNoBreak(int _maxInstrHoursNoBreak) {
		this.maxInstrHoursNoBreak = _maxInstrHoursNoBreak;
	}

	public int getMaxInstrHoursPerDay() {
		return maxInstrHoursPerDay;
	}

	public void setMaxInstrHoursPerDay(int _maxInstrHoursPerDay) {
		this.maxInstrHoursPerDay = _maxInstrHoursPerDay;
	}
	
	/***********Public methods that define the class behavior**************/
	/**
	 * Returns the total number of penalty point for the solution given 
	 * @param solution
	 * @return
	 */
	public long CalculateTotalNrOfPenaltyPoints()
	{
		long totalPPoints = 0;
		for(Integer instructorId : this.solution.GetAllInstructorsIds())
		{
			totalPPoints += GetPenaltyPointsForInstructor(instructorId);
		}
		
		return totalPPoints;
	}
	
	/**
	 * Determines the penalty points for a class by subtracting from the pPoints gained
	 *  with the class assigned the pPoints gained with the class unassigned
	 * @param solution
	 * @param selClass
	 * @return
	 */
	public long GetNrOfPenaltyPointsForVariable(Solution solution, Class aClass)
	{		
		int dayAndTimeSlot = this.solution.GetAssignedDayAndTimeSlot(aClass.getId());
		int instructorId = aClass.getAssignedInstructorId();
		
		long pPointsWithClass = GetPenaltyPointsForInstructor(instructorId);
		unassignManager.Unassign(aClass);
		Long pPointsWithoutClass = GetPenaltyPointsForInstructor(instructorId);
		assignManager.Assign(aClass, dayAndTimeSlot);
		
		return pPointsWithClass - pPointsWithoutClass;
	}
	
	/**
	 * Returns the penalty points calculated for a given set of classes
	 * @param instrClasses
	 * @param nrOfDays
	 * @param nrOfTimeSlotsPerDay
	 * @return
	 */
	public long GetPenaltyPointsForInstructor(int instructorId)
	{
		long totalPenaltyPoints = 0;
		int nrOfDays = this.solution.getTimeslotPattern().getNrOfDays();
		int nrOfTimeSlotsPerDay = this.solution.getTimeslotPattern().getNrOfTimeSlotsPerDay();
		// Helper variables
		int lastOccupiedHour;
		int nrOfConsecutiveHours;
		int hoursOfWorkPerDay;
		// Calculate the number of working hour per day, 
		// and the number of consecutive working hours
		for(int i=0; i<nrOfDays; i++)
		{
			// Reset variables
			lastOccupiedHour = 0;
			nrOfConsecutiveHours = 0;
			hoursOfWorkPerDay = 0;
			// For each time of day
			for(int j=0; j< nrOfTimeSlotsPerDay; j++)
			{
				int dayAndTimeSlot = i*nrOfDays + j;
				if(!this.solution.IsInstructorFree(instructorId, dayAndTimeSlot))
				{
					// The slot is a working hour
					// Count consecutive hours
					if(j == 0)
					{
						nrOfConsecutiveHours++;
					}else{
						 if(lastOccupiedHour == j-1)
						 {
							 nrOfConsecutiveHours++; 
						 }else{
							 nrOfConsecutiveHours = 0;
						 }
					}
					// Check constraint and calculate penalty points
					if(nrOfConsecutiveHours > maxInstrHoursNoBreak)
					{
						totalPenaltyPoints += this.nrOfpenaltyPointsPerViolation;
					}
					lastOccupiedHour = j;
					hoursOfWorkPerDay++;
					if(hoursOfWorkPerDay > maxInstrHoursPerDay)
					{
						totalPenaltyPoints += getNrOfPenaltyPointsPerViolation();
					}
				}
			}
		}
		
		return totalPenaltyPoints;
	}
}
